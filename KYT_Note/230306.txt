UMG : 언리얼 모션그래픽



캐릭터의 체력바, 마나, 상태창 등, 

esc를 누르면 나오는 창이나 인벤토리창 등의 UI를 구현

이런 UI를 구현하기 쉽게 만들어 놓은 것이 UMG이다!








---------------------------------------------------------------------------------


UI : 게임 내의 기능과 사용자 사이의 인터페이스



UE3 때는 HUD가 존재했음
	-> 월드세팅의 게임모드에서 확인가능
	-> Head Up Display : 지금은 안쓰이는 기능

UE4 부터는 UMG가 추가되었음
	-> 간단한 UI제작부터 기존의 HUD까지 대체가능하게됨

따라서 우리는 UMG로 HUD와 UI, 그리고 인벤토리를 제작할것






---------------------------------------------------------------------------------

유저인터페이스의 사용자 위젯블루프린트를 새로 생성


블루프린트 : 완성된 c++ 클래스를 한번더 상속받아 확장 
	-> 마지막 상속을 BP로 하고, 즉각적인 테스트가 가능하다.

유저 위젯가지도 c++로 구현이 되어있다.
	-> 이를 블루프린트로 상속받아 사용하자



팔레트에 사용할 수 있는 여러 기능이 있음
	-> 이 역시 계층구조로 추가됨


가장 첫번째 계층에는 스케일 박스
가장먼저 스케일 박스 추가
	-> 스케일박의 역할 : 영역을 지정하고 자신 내부에 들어온 것들을
					자신의 크기에 맞게 키우거나 줄이는 역할
			-> 게임의 해상도에 맞게 UI가 맞춰져야하는데
			-> 스케일 박스를 이용하면 동일한 비율로 해상도에 맞게 조절됨


두번째 계층에는 크기박스를 추가
스케일박스의 자식으로 크기박스 추가
	-> size 박스 : 절대적인 크기를 지정함
		-> 가장 default가 되는 메인 해상도에 맞는 크기



---------------------------------------------------------------------------------

(언리얼에서 파일을 이동, 수정 등 파일 정리를 할때
	반드시 에디터 안에서 폴더를 이동하거나 해야함
	안그러면 참조 링크가 다 깨져버림 )





카메라에 비율의 제한을 둘것이다.

	-> 캐릭터의 카메라 컴포넌트에 있는 
		종횡비 제한을 체크한다.
	-> 이제 에디터의 화면비율이 달라져도, 플레이시에는 항상 일정한 비율을 유지한다.




현재 레벨의 UE11 게임모드는 Knight라는 클래스를 기본 pawn으로 지정했다.
	-> 얘는 기본적으로 카메라를 가지고 있다.
	-> c++로 되어있는 knight를 상속받는 블루프린트를 만들어서
	-> 종횡비 체크만 해줌 : 쉽게 변경하기위해 한것

마찬가지로 게임모드 역시 쉽게 설정을 변경하기위해
	-> c++로 구현되어있던 애를 블루프린트로 상속받아 쉽게 설정을 변경함



---------------------------------------------------------------------------------

이제 화면 전체를 감싸는 Main HUD를 만들고
	-> 이 Main HUD안에있는 세부적인 항목을 채워가보자


우리가 에디터에서 설정하는 해상도는 해상도가 이럴때 이렇게 보일것이다 라는것뿐
	-> 실제 해상도를 설정하지는 않음 : 미리보기 기능임
	-> 우측상단의 화면크기에서 미리보기 해상도를 설정하거나 커스텀으로 설정한다.

크기박스의 레이아웃을 지정한 해상도의 크기로 설정한다
	-> 1920, 1080 : 스케일박스와 동일하게 설정


(스케일박스와 크기박스는 자식을 하나밖에 못가짐)

3번째로  크기박스의 아래에 캔버스 패널을 생성

	-> 이 캔버스 패널은 자식을 여러개 가질 수 있다!!
	-> 이제 이 캔버스 패널의 자식으로 미니맵, HP, 등의 UI자식들이 생성될것!


---------------------------------------------------------------------------------

캔버스 패널의 자식으로 프로그레스 바를 추가함

	-> 팔레트에 있는 애들 전부 유저 위젯을 상속받은 애들이다.
	-> 결국 Main HUD는 자신과 같은 부모를 상속받은 애들을 자식으로 받음


앵커 : 닻 : UI의 위치를 고정하는 기준점
	-> 해당 UI를 어느쪽에 설정할지에 다라 맞게 설정하는것이 편함
	-> X,Y위치는 앵커를 기준으로 얼마나 떨어져 있는지 설정

정렬 : 자신의 중심 위치를 어느정도로 할지 정하는것: 전체크기를 정규화함
	-> 여기서 설정된값이 자신의 중심위치가 됨
	-> 0,0 이면 좌측 상단이 자신의 기준 위치



---------------------------------------------------------------------------------

프로그레스 바

	프로그레스의 퍼센트에 따라 외관색으로 설정된 색이 차오름

	-> 근데 기본으로 쓰면 너무 디자인이 구림
	-> 스타일 카테고리의배경이미지, 이미지 채우기를 원하는 에셋으로 설정할 수 있음


	-> 프로그레스바로 HP바 이미지를 설정하고
	-> 같은 세팅으로 HP바 프레임을 생성한다.
		-> 이렇게 해야 HP바가 프레임을 덮어쓰지 않음





---------------------------------------------------------------------------------

HP를 표시하는 프로그레스바와, 이미지를 개별적으로 생성했다.

	-> 이 두가지를 하나의 개념으로 묶어 관리하기 위해선?
	-> 확장시켜 다른 UI들도 묶어 구조화


새로운 UI 위젯 블루프린트를 생성
	-> 여기에 HP, MP생성 : 4개의 위젯
	-> 이 BP를 Main HUD에 한번에 놓을 수 있음 (사용자생성탭에 생김)

	-> MAIN HUD에 놓고 이 BP를 생성할때 설정한 크기로 바꿔주면 끝
	-> 만약 HP,MP의 세부적인걸 수정하려면 해당 BP에서 수정




---------------------------------------------------------------------------------

결국 Main HUD가 화면의 가장 앞에 그려져야함
	-> 화면에 그리기위해서 2가지방법 (블루프린트 & c++)
	-> BP는 쉽지만, 사용성은 C++이 좋음
		-> c++로 사용하자


	BP로 하는법 : 레벨 블루프린트를 열어 게임이 시작될때 레벨의 BeginPlay() 시
			-> 위젯생성 (Main HUD로 설정)하고 : BP의 인스턴스를 하나 생성하는 함수
			-> Add to ViewPort 노드를 추가 (앞의 노드에서 returh된 Main HUD 를 인자로 받음)
			=> 이렇게하면 되긴하는데 나중에 관리가 까다로움


	Cpp로 하는법: (각 레벨은 GameMode가 하나식 할당된다.)
			 (레벨이 생기면 하나의 GameMode가 생성됨)
			 (에디터의 월드세팅창 : 현재 레벨에 세팅된값: 게임모드도 볼 수 있음)

			-> 따라서 해당 게임모드 c++코드를 통해 HUD를 추가

			(BP는 언리얼에디터에서만 사용ㄷ가능한 자료형 비슷한것임)
			-> GameMode cpp에서 블루프린트로 만든 MainHUD를 불러와야한다???
			=> 어케함?	


---------------------------------------------------------------------------------

언리얼에는 UClass라는 개념이 존재함

	C++의 한계 ? 
	-> 런타임에 타입을 알기가 어렵다.
	
다형성 : 부모타입의 포인터로 자식 객체를 가리킬수있음
	-> 포인터로 접근할때는 부모타입으로 인식
	-> 근데 런타임중에 부모 포인터가 가리키는 객체의 실제 객체가 어떤것인지 아는방법?
		-> Dynamic Cast

	어떻게 아나?
	-> 상속관계에 가상함수를 하나만들면 type info가 생김
	-> 근데 상속관계에 가상함수가 없으면 알수가 없음

	따라서 Unreal은 이런 단점을 보완하기 위해 UClass라는 기능을 추가함
	-> 언리얼의 해결법
	UClass : 자료형 별로 해당자료형이 어떤 자료형인지에 대한 데이터
	-> 각 클래스마다의 정보를 담는 UClass가 존재
	-> MyClass::StaticClass() 를 호출하면 UClass를 반환하고
		-> MyClass에 대한 정보를 얻을 수 있음


---------------------------------------------------------------------------------

CDO : Class Default Object

	Unreal에는 CDO라는 개념이 존재함

	언리얼은 클래스를 하나 정의하면 해당 클래스의 객체를 하나 생성함
	-> 클래스의 원형이 되는 가장 default 오브젝트

	-> 이 CDO를 만들어야 엔진에서 해당 클래스의 멤버 등이 어떤지 알 수 있음
	

---------------------------------------------------------------------------------


다시 돌아와서

	Cpp 코드에서 BP를 읽어와야함
	-> UClass 는 cpp클래스나, BP나 둘다 존재함
	-> 따라서 해당 BP의 UClass를 참조해야함
		
먼저 Build.cd에서 모듈을 추가해야함
	-> "UMG" 모듈 추가
	-> ConstructorHelpers::FClassFinder로 UUserWidget를 찾음
		-> 우리가 만든 MainHUD는 UUserWidget을 상속받기 때문
		-> 해당 finder 변수를 생성 후 TEXT로 원하는 클래스의 레퍼런스 경로를 적어주고
		-> 클래스이므로 경로의 마지막에 _C를 추가해준다.
		-> 해당 Finder의 class를 멤버로 저장함
		-> 이 멤버에서 AddToViewPort를 호출




---------------------------------------------------------------------------------

HUD를 제어하는 기능

	-> 유저위젯을 바로 상속받지 않고
		-> Base (cpp)가 유저위젯을 상속받고, 다시 이 Base를 Main HUD가 상속받는식으로 하자
		-> HUD를 제어하는 기능은 Base에서 정의한다.











---------------------------------------------------------------------------------
















---------------------------------------------------------------------------------
